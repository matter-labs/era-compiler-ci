name: Foundry tests

on:
  workflow_call:
    inputs:
      upload-reports:
        description: 'Upload reports to the PR.'
        type: string
        required: false
        default: "true"
      solx_candidate_branch:
        description: 'Specific `solx` candidate ref to use for building `solx`.'
        type: string
        required: false
        default: ''
      solx_reference_branch:
        description: 'Specific `solx` reference ref to use for building `solx`.'
        type: string
        required: false
        default: ''
      solx-repo:
        type: string
        required: false
        default: 'matter-labs/solx'
        description: 'Solx repository to use. Required for forks testing.'
      compiler_llvm_candidate_branch:
        description: 'Specific LLVM candidate ref to use for building `solx`.'
        type: string
        required: false
        default: ''
      compiler_llvm_reference_branch:
        description: 'Specific LLVM reference ref to use for building `solx`.'
        type: string
        required: false
        default: 'main'
      compiler-llvm-repo:
        type: string
        required: false
        default: 'matter-labs/era-compiler-llvm'
        description: 'Compiler LLVM repository to use. Required for forks testing.'
      print-markdown-tables:
        description: 'Report markdown tables to the PRs.'
        type: string
        required: false
        default: "true"
      excel-reports:
        description: 'Generate and upload Excel reports.'
        type: string
        required: false
        default: "true"

permissions:
  contents: read
  pull-requests: write

# Cancel the workflow if any new changes pushed to a feature branch or the trunk
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash -ex {0}

env:
  BENCHMARKS_TOML: '.github/forge-benchmarks.toml'

jobs:

  build-solx:
    runs-on: matterlabs-ci-runner-high-performance
    container:
      image: ghcr.io/matter-labs/zksync-llvm-runner:latest
    strategy:
      fail-fast: false
      matrix:
        type: ["reference", "candidate"]
    steps:

      - name: Checkout source
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.solx-repo }}
          submodules: 'recursive'
          ref: ${{ matrix.type == 'candidate' && inputs.solx_candidate_branch || inputs.solx_reference_branch || '' }}

      # This step is required to checkout submodules
      # that are disabled in .gitmodules config
      - name: Checkout submodules
        run: |
          git config --global --add safe.directory '*'
          git submodule update --init --force --depth=1 --recursive --checkout

      - name: Remove llvm submodule
        if: ${{ contains(github.repository, 'era-compiler-llvm') }}
        run: rm -rf llvm

      - name: Checkout llvm
        if: ${{ contains(github.repository, 'era-compiler-llvm') }}
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.compiler-llvm-repo }}
          path: llvm
          ref: ${{ matrix.type == 'candidate' && inputs.compiler_llvm_candidate_branch || inputs.compiler_llvm_reference_branch }}

      - name: Building solc
        uses: matter-labs/era-compiler-ci/.github/actions/build-solc@v1
        with:
          cmake-build-type: 'Release'
          working-dir: 'era-solidity'
          upload-testing-binary: false

      - name: Build LLVM
        uses: matter-labs/era-compiler-ci/.github/actions/build-llvm@v1
        with:
          clone-llvm: 'false'
          build-type: Release
          enable-assertions: 'false'
          ccache-key: ${{ format('llvm-{0}-{1}', runner.os, runner.arch) }}

      - name: Build solx
        uses: matter-labs/era-compiler-ci/.github/actions/build-rust@v1
        env:
          BOOST_PREFIX: ${{ github.workspace }}/era-solidity/boost/lib
          SOLC_PREFIX: ${{ github.workspace }}/era-solidity/build
        with:
          exec_name: 'solx'
          target: 'x86_64-unknown-linux-gnu'
          release-suffix: test-${{ matrix.type }}

  # Special job to separate projects by chunks
  # and execute chunks in parallel later.
  prepare-projects:
    runs-on: ubuntu-latest
    outputs:
      projects: ${{ steps.projects.outputs.projects }}
    env:
      MAX_RUNNERS: 6 # how many max runners we can occupy in parallel
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: matter-labs/solx
          ref: ${{ inputs.solx_candidate_branch || 'main' }}
          sparse-checkout: |
            ${{ env.BENCHMARKS_TOML }}

      - name: Prepare projects
        id: projects
        run: |
          # Filter huge projects in PRs
          if [[ ${{ github.event_name }} == 'pull_request' ]]; then
            projects=$(yq 'to_entries | map(select(.value.category != "huge")) | .[].key' ${BENCHMARKS_TOML} | tr '\n' ' ')
            projects_len=$(yq 'to_entries | map(select(.value.category != "huge")) | length' ${BENCHMARKS_TOML})
          else
            projects=$(yq '. as $root | keys[]' ${BENCHMARKS_TOML} | tr '\n' ' ')
            projects_len=$(yq '. | keys | length' ${BENCHMARKS_TOML})
          fi
          read -a arr <<< "${projects}"
          chunk_size="$(( (projects_len + MAX_RUNNERS - 1) / MAX_RUNNERS ))"
          groups=()
          for ((i=0; i<${#arr[@]}; i+=chunk_size)); do
            group="${arr[@]:i:chunk_size}"
            groups+=("$group")
          done
          JSON=$(jq -cn --argjson g "$(printf '%s\n' "${groups[@]}" | jq -R . | jq -s .)" '$g')
          echo "projects=${JSON}" >> ${GITHUB_OUTPUT}

  test:
    needs: [build-solx, prepare-projects]
    runs-on: matterlabs-ci-runner-high-performance
    env:
      DEFAULT_ITERATIONS: 1
      FOUNDRY_INVARIANT_RUNS: 0
      FOUNDRY_INVARIANT_DEPTH: 0
    outputs:
      solx-version: ${{ steps.solx.outputs.solx-version }}
      solx-latest-release-version: ${{ steps.solx.outputs.solx-latest-release-version }}
      solx-tot-version: ${{ steps.solx.outputs.solx-tot-version }}
      solx-llvm-version: ${{ steps.solx.outputs.solx-llvm-version }}
      solc-base-version: ${{ steps.solx.outputs.solc-base-version }}
      compilation_json: ${{ steps.tests.outputs.compilation_json }}
      latest-release: ${{ steps.solx.outputs.latest-release }}
      short-sha: ${{ steps.solx.outputs.short-sha }}
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJSON(needs.prepare-projects.outputs.projects) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: matter-labs/solx
          ref: ${{ inputs.solx_candidate_branch || 'main' }}
          sparse-checkout: |
            ${{ env.BENCHMARKS_TOML }}

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release*
          merge-multiple: true
          path: .

      - name: Setup solx
        id: solx
        env:
          SOLX_DOWNLOAD_URL: 'https://github.com/matter-labs/solx/releases/download'
        run: |
          mkdir -p compilers
          cd compilers
          SHA="${{ github.event.pull_request.head.sha || github.sha }}"
          SHORT_SHA="${SHA:0:7}"
          mv ${GITHUB_WORKSPACE}/test-candidate/solx-test-candidate ${GITHUB_WORKSPACE}/compilers/solx-llvm.${SHORT_SHA}
          mv ${GITHUB_WORKSPACE}/test-reference/solx-test-reference ${GITHUB_WORKSPACE}/compilers/solx-ToT
          # Setup latest release solx
          LATEST_RELEASE=$(curl -s \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/matter-labs/solx/releases/latest \
            | jq -r .tag_name)
          wget "${SOLX_DOWNLOAD_URL}/${LATEST_RELEASE}/solx-linux-amd64-gnu-v${LATEST_RELEASE}"
          mv ./solx-linux-amd64-gnu-v${LATEST_RELEASE} ./solx-${LATEST_RELEASE}
          chmod a+x ./solx-llvm.${SHORT_SHA}
          chmod a+x ./solx-ToT
          chmod a+x ./solx-${LATEST_RELEASE}
          SOLX_VERSION=$(./solx-llvm.${SHORT_SHA} --version | head -n 1)
          SOLX_LATEST_RELEASE_VERSION=$(./solx-${LATEST_RELEASE} --version | head -n 1)
          SOLX_TOT_VERSION=$(./solx-ToT --version | head -n 1)
          SOLX_SOLC_VERSION=$(./solx-llvm.${SHORT_SHA} --version | tail -n 1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
          LLVM_VERSION=$(echo "${SOLX_VERSION}" | grep -oP "(?<=LLVM build: )[a-f0-9]{40}")
          echo "short-sha=${SHORT_SHA}" >> ${GITHUB_OUTPUT}
          echo "solx-version=${SOLX_VERSION}" >> ${GITHUB_OUTPUT}
          echo "solx-latest-release-version=${SOLX_LATEST_RELEASE_VERSION}" >> ${GITHUB_OUTPUT}
          echo "solx-tot-version=${SOLX_TOT_VERSION}" >> ${GITHUB_OUTPUT}
          echo "solx-llvm-version=${LLVM_VERSION}" >> ${GITHUB_OUTPUT}
          echo "solc-base-version=${SOLX_SOLC_VERSION}" >> ${GITHUB_OUTPUT}
          echo "latest-release=${LATEST_RELEASE}" >> ${GITHUB_OUTPUT}

      - name: Install foundry
        run: |
          curl -L https://foundry.paradigm.xyz | bash
          export PATH="$PATH:${HOME}/.foundry/bin"
          echo ${HOME}/.foundry/bin >> "${GITHUB_PATH}"
          foundryup

      - name: Install yq
        env:
          YQ_DOWNLOAD_URL: https://github.com/mikefarah/yq/releases/download/v4.45.4/yq_linux_amd64
        run: |
          wget "${YQ_DOWNLOAD_URL}"
          mv yq_linux_amd64 yq
          chmod +x yq

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Yarn
        run: npm install -g yarn

      # Some projects might use hardcoded ssh urls
      # force git to use https instead
      - name: Git https settings
        run: |
          git config --global url."https://github.com/".insteadOf git@github.com:
          git config --global url."https://".insteadOf git://

      - name: Run tests
        id: tests
        run: |
          mkdir -p projects
          compilation_json='{}'
          TOML_CONFIG="${GITHUB_WORKSPACE}/${BENCHMARKS_TOML}"
          export PATH="${GITHUB_WORKSPACE}:${PATH}"
          for PROJECT in ${{ matrix.project }}; do
            DISABLED=$(yq ".${PROJECT}.disabled" "${TOML_CONFIG}")
            if [[ "${DISABLED}" == "true" ]]; then
              echo "Skipping ${PROJECT} as it is disabled"
              continue
            fi
            # Set env variables for a project if any
            while IFS='=' read -r key value; do
              if [[ -n "${key}" ]]; then
                export "${key}=${value}"
                echo "Exported env variable: ${key}=${value} for ${PROJECT}."
              fi
            done < <(
              yq -oj ".${PROJECT}.env // {} | to_entries[]" "${TOML_CONFIG}" |
                jq -r 'select(.key != null) | .key + "=" + (.value | tostring)'
            )
            for COMPILER in solc solx-llvm.${{ steps.solx.outputs.short-sha }} solx-ToT solx-${{ steps.solx.outputs.latest-release }}; do
              for VIA_IR in true false; do
                REPO=$(yq ".${PROJECT}.repo" "${TOML_CONFIG}")
                if [ -d "${GITHUB_WORKSPACE}/projects/${PROJECT}" ]; then
                  cd ${GITHUB_WORKSPACE}/projects
                  rm -rf "${GITHUB_WORKSPACE}/projects/${PROJECT}"
                fi
                git clone --depth 1 "${REPO}" "${GITHUB_WORKSPACE}/projects/${PROJECT}" --recurse-submodules
                cd "${GITHUB_WORKSPACE}/projects/${PROJECT}"
                echo "Running tests for ${PROJECT} with ${COMPILER} via-ir=${VIA_IR}"

                REQUIRES_YARN=$(yq ".${PROJECT}.requires_yarn" "${TOML_CONFIG}")
                if [[ "${REQUIRES_YARN}" == "true" ]]; then
                  echo "Installing yarn dependencies for ${PROJECT}"
                  yarn install
                fi

                # Replace solidity version in all .sol files
                find . -name "*.sol" -type f -exec \
                  sed -i 's/pragma solidity [0-9]\+\.[0-9]\+\.[0-9]\+/pragma solidity ${{ steps.solx.outputs.solc-base-version }}/g' {} +
                # Fix config if required
                forge config --fix
                sed -i '/deny_warnings.*/d' foundry.toml
                sed -i '/evm_version.*/d' foundry.toml
                sed -i '/via_ir.*/d' foundry.toml
                sed -i 's/solc.*/solc_version = "${{ steps.solx.outputs.solc-base-version }}"/' foundry.toml
                sed -i 's/solc_version.*/solc_version = "${{ steps.solx.outputs.solc-base-version }}"/' foundry.toml
                # Build project
                [[ ${COMPILER} == *solx* ]] && USE_SOLX="--use ${GITHUB_WORKSPACE}/compilers/${COMPILER}" || USE_SOLX=""
                [ ${VIA_IR} == 'true' ] && VIA_IR_SUFFIX="-viaIR" || VIA_IR_SUFFIX=""
                [ ${VIA_IR} == 'true' ] && VIA_IR_OPTION="--via-ir" || VIA_IR_OPTION=""
                mkdir -p ${GITHUB_WORKSPACE}/${COMPILER}${VIA_IR_SUFFIX}
                BUILD_JSON="${GITHUB_WORKSPACE}/${COMPILER}${VIA_IR_SUFFIX}/build_${PROJECT}.json"
                BUILD_SIZES_JSON="${GITHUB_WORKSPACE}/${COMPILER}${VIA_IR_SUFFIX}/build_sizes_${PROJECT}.json"

                start_ms=$(date +%s%3N)
                forge build --optimize --no-metadata --force ${USE_SOLX} ${VIA_IR_OPTION} --json > ${BUILD_JSON} 2>/dev/null || true
                end_ms=$(date +%s%3N)
                elapsed_ms=$(( end_ms - start_ms ))
                COMPILE_TIME=$(awk -v ms="${elapsed_ms}" 'BEGIN { printf "%.3f\n", ms / 1000 }')

                # Get build size report
                forge build --optimize --no-metadata --sizes ${USE_SOLX} ${VIA_IR_OPTION} --json > ${BUILD_SIZES_JSON} 2>/dev/null || true

                if [[ ${COMPILER} == *solx* ]]; then
                  TOOLCHAIN="${COMPILER}${VIA_IR_SUFFIX}"
                else
                  TOOLCHAIN="${COMPILER}-${{ steps.solx.outputs.solc-base-version }}${VIA_IR_SUFFIX}"
                fi

                sed -i '/Error: some contracts exceed the runtime size limit/d' "${BUILD_SIZES_JSON}"

                # Strip all errors in stdout
                sed -i '/ERROR/d' "${BUILD_SIZES_JSON}"

                if jq empty "${BUILD_SIZES_JSON}" > /dev/null 2>&1 && [ -s "${BUILD_SIZES_JSON}" ]; then
                  jq --arg project "${PROJECT}" --arg toolchain "${TOOLCHAIN}" \
                    '{data: ., project: $project, toolchain: $toolchain}' \
                    "${BUILD_SIZES_JSON}" > tmp.json
                  mv tmp.json "${BUILD_SIZES_JSON}"
                else
                  echo "Invalid gas JSON: ${BUILD_SIZES_JSON}"
                  cat "${BUILD_SIZES_JSON}"
                fi

                if jq empty "${BUILD_JSON}" > /dev/null 2>&1 && [ -s "${BUILD_JSON}" ]; then
                  jq --arg k "compile_time" --argjson v "${COMPILE_TIME}" '. + {($k): $v}' "${BUILD_JSON}" > tmp.json
                  mv tmp.json "${BUILD_JSON}"
                else
                  echo "Build failed for ${PROJECT} with ${COMPILER} via-ir=${VIA_IR}:"
                  cat "${BUILD_JSON}"
                  continue
                fi

                if jq -e 'has("errors") and (.errors | type == "array") and (.errors | length > 0)' ${BUILD_JSON} > /dev/null; then
                  echo "Errors found in ${BUILD_JSON} for ${PROJECT} with ${COMPILER} via-ir=${VIA_IR}:"
                  jq -r '
                    .errors[] |
                    "ðŸ” File: \(.sourceLocation.file // "N/A")\n" +
                    "   ðŸ”¹ Type: \(.type)\n" +
                    "   ðŸ”¹ Severity: \(.severity)\n" +
                    "   ðŸ”¹ Error Code: \(.errorCode)\n" +
                    "   ðŸ”¹ Message:\n     \(.message | gsub("\n"; "\n     "))\n" +
                    "------------------------------------------------------------"
                    ' "${BUILD_JSON}"
                fi

                # Check if there are any errors in src/ directory, we should not run the tests then
                if jq -e '
                  has("errors") and
                  (.errors | type == "array") and
                  (.errors[]? |
                    .severity == "error" and
                    (.sourceLocation.file? | type == "string" and startswith("src/"))
                  )' "${BUILD_JSON}" > /dev/null; then
                  echo "â­ï¸ Skipping ${BUILD_JSON} due to error in src/"
                  continue
                fi

                COMPILE_ONLY=$(yq ".${PROJECT}.compile_only" "${TOML_CONFIG}")
                if [[ "${COMPILE_ONLY}" == "true" ]]; then
                  echo "Skipping tests for ${PROJECT} as compile_only is set to true"
                  continue
                fi

                TEST_JSON="${GITHUB_WORKSPACE}/${COMPILER}${VIA_IR_SUFFIX}/test_${PROJECT}.json"
                GAS_JSON="${GITHUB_WORKSPACE}/${COMPILER}${VIA_IR_SUFFIX}/${PROJECT}.json"
                start_ms=$(date +%s%3N)
                forge test --optimize --no-metadata --fuzz-runs=0 --fuzz-seed=0xdeadbeef ${VIA_IR_OPTION} --json ${USE_SOLX} ${DEFAULT_SKIP_TESTS} ${SKIP_TESTS} >"${TEST_JSON}" 2>/dev/null || true
                end_ms=$(date +%s%3N)
                elapsed_ms=$(( end_ms - start_ms ))
                RUN_TIME=$(awk -v ms="${elapsed_ms}" 'BEGIN { printf "%.3f\n", ms / 1000 }')
                jq --arg k "exec_time" --argjson v "${RUN_TIME}" '. + {($k): $v}' "${BUILD_JSON}" > tmp.json
                mv tmp.json "${BUILD_JSON}"

                # Report runtime failures if any
                if jq -e '
                  to_entries | map(.value.test_results | to_entries | map(select(.value.status == "Failure"))) | flatten | length > 0
                  ' "${TEST_JSON}" > /dev/null; then
                    echo "âŒ Failing Tests:"
                    jq -r '
                      to_entries[] as $contract |
                      $contract.value.test_results
                      | to_entries[]
                      | select(.value.status == "Failure")
                      | "âŒ Test: \($contract.key) / \(.key)\n   ðŸ”¹ Reason: \(.value.reason // "No reason provided")\n-----------------------------"
                    ' "${TEST_JSON}"
                fi

                GAS_REPORTS="${GITHUB_WORKSPACE}/${COMPILER}${VIA_IR_SUFFIX}/${PROJECT}-gas-reports"
                mkdir -p "${GAS_REPORTS}"

                ITERATIONS=$(yq ".${PROJECT}.run_iterations // ${DEFAULT_ITERATIONS}" "${TOML_CONFIG}")
                for ITER in $(seq "${ITERATIONS}"); do
                  GAS_JSON_ITER="${GAS_REPORTS}/${PROJECT}_${ITER}.json"
                  forge test --optimize --no-metadata --fuzz-runs=0 --fuzz-seed=0xdeadbeef --gas-report ${VIA_IR_OPTION} --json ${USE_SOLX} ${DEFAULT_SKIP_TESTS} ${SKIP_TESTS} >"${GAS_JSON_ITER}" 2>/dev/null || true
                done

                # Strip all errors in stdout
                sed -i '/ERROR/d' "${GAS_JSON_ITER}"

                # Convert gas JSON reports to benchmark converter format
                for JSON in ${GAS_REPORTS}/*.json; do
                  if [[ ${COMPILER} == *solx* ]]; then
                    TOOLCHAIN="${COMPILER}${VIA_IR_SUFFIX}"
                  else
                    TOOLCHAIN="${COMPILER}-${{ steps.solx.outputs.solc-base-version }}${VIA_IR_SUFFIX}"
                  fi
                  if jq empty "${JSON}" > /dev/null 2>&1 && [ -s "${JSON}" ]; then
                    jq --arg project "${PROJECT}" --arg toolchain "${TOOLCHAIN}" \
                      '{data: ., project: $project, toolchain: $toolchain}' \
                      "${JSON}" > tmp.json
                    mv tmp.json "${JSON}"
                  else
                    echo "Invalid gas JSON: ${JSON}"
                    cat "${JSON}"
                  fi
                done

              done
            done
            # Clean-up environment variables for the project
            while IFS= read -r key; do
              unset "${key}"
              echo "Unset environment variable ${key} for ${PROJECT}."
            done < <(
              yq -oj ".${PROJECT}.env // {} | to_entries[]" "${TOML_CONFIG}" | jq -r '.key'
            )
          done

      - name: Export matrix projects
        id: projects
        run: |
          PROJECTS="${{ matrix.project }}"
          echo "projects=${PROJECTS// /_}" >> ${GITHUB_OUTPUT}

      - name: Upload jsons
        uses: actions/upload-artifact@v4
        with:
          name: results-${{ steps.projects.outputs.projects }}
          path: 'sol*/'


  prepare-md-tables:
    if: ${{ inputs.print-markdown-tables == 'true' }}
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: matter-labs/solx
          ref: ${{ inputs.solx_candidate_branch || 'main' }}
          sparse-checkout: |
            ${{ env.BENCHMARKS_TOML }}

      - name: Download reports
        uses: actions/download-artifact@v4
        with:
          path: data
          merge-multiple: 'true'

      - name: Prepare compatibility table
        run: |
          echo "| Project     | Mode     | Compiled (solc / solx / Total)         | Passed (solc / solx / Total)           |" > report.md
          echo "|-------------|----------|----------------------------------------|-----------------------------------------|" >> report.md

          PROJECTS=$(yq '. as $root | keys[]' ${BENCHMARKS_TOML} | tr '\n' ' ')
          for PROJECT in ${PROJECTS}; do
            DISABLED=$(yq ".${PROJECT}.disabled" "${BENCHMARKS_TOML}")
            if [[ "${DISABLED}" == "true" ]]; then
              echo "Skipping ${PROJECT} as it is disabled"
              continue
            fi
            for MODE in "default" "viaIR"; do
              if [ "${MODE}" = "default" ]; then
                JSON="data/solx-llvm.${{ needs.test.outputs.short-sha }}/build_${PROJECT}.json"
                RUN_JSON="data/solx-llvm.${{ needs.test.outputs.short-sha }}/test_${PROJECT}.json"
                RUN_REF_JSON="data/solc/test_${PROJECT}.json"
                BUILD_REF_JSON="data/solc/build_${PROJECT}.json"
              else
                JSON="data/solx-llvm.${{ needs.test.outputs.short-sha }}-viaIR/build_${PROJECT}.json"
                RUN_JSON="data/solx-llvm.${{ needs.test.outputs.short-sha }}-viaIR/test_${PROJECT}.json"
                RUN_REF_JSON="data/solc-viaIR/test_${PROJECT}.json"
                BUILD_REF_JSON="data/solc-viaIR/build_${PROJECT}.json"
              fi

              # --- Reference (solc) compile totals ---
              REF_COMPILE_TOTAL=0
              REF_COMPILE_PASSED=0
              if jq empty "${BUILD_REF_JSON}" > /dev/null 2>&1 && [ -s "${BUILD_REF_JSON}" ]; then
                REF_COMPILE_TOTAL=$(jq -r '.build_infos[0].source_id_to_path | length' "$BUILD_REF_JSON")
                REF_FAILURES=$(jq -r '[.errors[] | select(.type == "Error")] | length' "$BUILD_REF_JSON")
                REF_COMPILE_PASSED=$((REF_COMPILE_TOTAL - REF_FAILURES))
              fi

              # --- Reference (solc) test totals ---
              REF_TEST_TOTAL=0
              REF_TEST_PASSED=0
              if jq empty "${RUN_REF_JSON}" > /dev/null 2>&1 && [ -s "${RUN_REF_JSON}" ]; then
                REF_TEST_RESULTS_JSON=$(
                  jq '
                    reduce to_entries[] as $contract (
                      {total:0, success:0};
                      reduce ($contract.value.test_results | to_entries)[] as $test (
                        .;
                        .total += 1 |
                        .success += (if $test.value.status == "Success" then 1 else 0 end)
                      )
                    )' "${RUN_REF_JSON}"
                )
                REF_TEST_TOTAL=$(echo "${REF_TEST_RESULTS_JSON}" | jq -r '.total')
                REF_TEST_PASSED=$(echo "${REF_TEST_RESULTS_JSON}" | jq -r '.success')
              fi

              # --- solx compile results ---
              SOLX_COMPILE_PASSED=0
              if jq empty "${JSON}" > /dev/null 2>&1 && [ -s "${JSON}" ]; then
                SOLX_SRC_TOTAL=$(jq -r '.build_infos[0].source_id_to_path | length' "$JSON")
                SOLX_FAILURES=$(jq -r '[.errors[] | select(.type == "Error")] | length' "$JSON")
                SOLX_COMPILE_PASSED=$((SOLX_SRC_TOTAL - SOLX_FAILURES))
              fi

              # --- solx test results ---
              SOLX_TEST_PASSED=0
              if jq empty "${RUN_JSON}" > /dev/null 2>&1 && [ -s "${RUN_JSON}" ]; then
                SOLX_TEST_RESULTS_JSON=$(
                  jq '
                    reduce to_entries[] as $contract (
                      {success:0};
                      reduce ($contract.value.test_results | to_entries)[] as $test (
                        .;
                        .success += (if $test.value.status == "Success" then 1 else 0 end)
                      )
                    )' "${RUN_JSON}"
                )
                SOLX_TEST_PASSED=$(echo "${SOLX_TEST_RESULTS_JSON}" | jq -r '.success')
              fi

              # --- Single-bar generator (10 slots, filled by solx vs solc total) ---
              gen_bar() {
                local passed=$1
                local total=$2

                local percent=0
                if (( total > 0 )); then
                  percent=$(( passed * 100 / total ))
                fi
                # clamp to [0,100] just in case
                (( percent < 0 )) && percent=0
                (( percent > 100 )) && percent=100

                local filled=$(( percent / 10 ))

                # Use red unless fully complete
                local fill_char="ðŸŸ¥"
                (( percent == 100 )) && fill_char="ðŸŸ©"

                local empty_char="â¬œ"
                local bar=""
                for (( i=1; i<=10; i++ )); do
                  if (( i <= filled )); then
                    bar+="$fill_char"
                  else
                    bar+="$empty_char"
                  fi
                done
                echo "$bar"
              }

              # Bars
              COMPILE_BAR=$(gen_bar "$SOLX_COMPILE_PASSED" "$REF_COMPILE_TOTAL")
              TEST_BAR=$(gen_bar "$SOLX_TEST_PASSED" "$REF_TEST_PASSED")
              # if solc total = 0, show full green
              if [ "$REF_TEST_TOTAL" -eq 0 ]; then
                TEST_BAR="ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©"
              fi
              if [ "$REF_COMPILE_TOTAL" -eq 0 ]; then
                COMPILE_BAR="ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©"
              fi

              # --- Output rows ---
              if [ "$MODE" = "default" ]; then
                printf "| %-11s | %-8s | %-10s %4d / %4d / %4d | %-10s %4d / %4d / %4d |\n" \
                  "${PROJECT}" "${MODE}" \
                  "${COMPILE_BAR}" "${REF_COMPILE_PASSED}" "${SOLX_COMPILE_PASSED}" "${REF_COMPILE_TOTAL}" \
                  "${TEST_BAR}"    "${REF_TEST_PASSED}"    "${SOLX_TEST_PASSED}"    "${REF_TEST_TOTAL}" >> report.md
              else
                printf "| %-11s | %-8s | %-10s %4d / %4d / %4d | %-10s %4d / %4d / %4d |\n" \
                  "" "${MODE}" \
                  "${COMPILE_BAR}" "${REF_COMPILE_PASSED}" "${SOLX_COMPILE_PASSED}" "${REF_COMPILE_TOTAL}" \
                  "${TEST_BAR}"    "${REF_TEST_PASSED}"    "${SOLX_TEST_PASSED}"    "${REF_TEST_TOTAL}" >> report.md
              fi
            done
          done

      - name: Prepare compilation and run time table
        run: |
          echo "| Project     | Mode     | Compile (solx/solc/Î”s/Î”%)  | Run (solx/solc/Î”s/Î”%)  | Size warnings (solx/solc) |" > time_report.md
          echo "|-------------|----------|----------------------------|------------------------|---------------------------|" >> time_report.md

          PROJECTS=$(yq '. as $root | keys[]' ${BENCHMARKS_TOML} | tr '\n' ' ')
          for PROJECT in ${PROJECTS}; do
            DISABLED=$(yq ".${PROJECT}.disabled" "${BENCHMARKS_TOML}")
            if [[ "${DISABLED}" == "true" ]]; then
              echo "Skipping ${PROJECT} as it is disabled"
              continue
            fi
            # TODO: skip cicada for now as solc can't compile it
            if [[ "${PROJECT}" == "cicada" ]]; then
              echo "Skipping ${PROJECT} as it is not supported by solc"
              continue
            fi
            for MODE in "default" "viaIR"; do
              [ "${MODE}" = "viaIR" ] && SUFFIX="-viaIR" || SUFFIX=""
              JSON="data/solx-llvm.${{ needs.test.outputs.short-sha }}${SUFFIX}/build_${PROJECT}.json"
              REF_JSON="data/solc${SUFFIX}/build_${PROJECT}.json"

              if [ ! -s "$JSON" ] || [ ! -s "$REF_JSON" ]; then
                echo "No data for ${PROJECT} [$MODE]"
                continue
              fi

              if ! (jq empty "${JSON}" > /dev/null 2>&1 && [ -s "${JSON}" ]); then
                echo "Invalid JSON for ${PROJECT} [${MODE}]: ${JSON}"
                continue
              fi

              # Bytecode size exceeds limit
              BYTECODE_WARN_SOLX=$(jq '[.errors[] | select(.errorCode == "5574" or .errorCode == "3860")] | length' "${JSON}")
              BYTECODE_WARN_SOLC=$(jq '[.errors[] | select(.errorCode == "5574" or .errorCode == "3860")] | length' "${REF_JSON}")
              BYTECODE_COLUMN=$(printf "%d / %d" "${BYTECODE_WARN_SOLX}" "${BYTECODE_WARN_SOLC}")

              COMPILE_SOLX=$(jq -r '.compile_time // 0' "${JSON}")
              COMPILE_SOLC=$(jq -r '.compile_time // 0' "${REF_JSON}")
              RUN_SOLX=$(jq -r '.exec_time // 0' "${JSON}")
              RUN_SOLC=$(jq -r '.exec_time // 0' "${REF_JSON}")

              # Compute differences
              COMPILE_DIFF=$(awk "BEGIN { printf \"%.2f\", ${COMPILE_SOLX} - ${COMPILE_SOLC} }")
              COMPILE_PCT=$(awk -v solc="$COMPILE_SOLC" -v solx="$COMPILE_SOLX" 'BEGIN {
                if (solc == 0)
                  print "N/A";
                else
                  printf "%+.0f%%", ((solx - solc) / solc) * 100
              }')

              RUN_DIFF=$(awk "BEGIN { printf \"%.2f\", ${RUN_SOLX} - ${RUN_SOLC} }")
              RUN_PCT=$(awk -v solc="$RUN_SOLC" -v solx="$RUN_SOLX" 'BEGIN {
                if (solc == 0)
                  print "N/A";
                else
                  printf "%+.0f%%", ((solx - solc) / solc) * 100
              }')

              # Compile emoji
              COMPILE_EMOJI=$(awk -v solc="$COMPILE_SOLC" -v solx="$COMPILE_SOLX" 'BEGIN {
                diff = solx - solc;
                pct = (solc > 0) ? (diff / solc) * 100 : 0;
                if (pct > 5) print "ðŸ“ˆ";
                else if (pct < -5) print "ðŸ“‰";
                else print "âž–";
              }')

              # Run emoji
              RUN_EMOJI=$(awk -v solc="$RUN_SOLC" -v solx="$RUN_SOLX" 'BEGIN {
                diff = solx - solc;
                pct = (solc > 0) ? (diff / solc) * 100 : 0;
                if (pct > 5) print "ðŸ“ˆ";
                else if (pct < -5) print "ðŸ“‰";
                else print "âž–";
              }')

              COMPILE_COLUMN=$(printf "%.2fs / %.2fs / %+0.2fs / %s %s" "$COMPILE_SOLX" "$COMPILE_SOLC" "$COMPILE_DIFF" "$COMPILE_PCT" "$COMPILE_EMOJI")
              RUN_COLUMN=$(printf "%.2fs / %.2fs / %+0.2fs / %s %s" "$RUN_SOLX" "$RUN_SOLC" "$RUN_DIFF" "$RUN_PCT" "$RUN_EMOJI")

              if [ "$MODE" = "default" ]; then
                printf "| %-11s | %-8s | %-28s | %-24s | %-27s |\n" \
                  "${PROJECT}" "${MODE}" "${COMPILE_COLUMN}" "${RUN_COLUMN}" "${BYTECODE_COLUMN}" >> time_report.md
              else
                printf "| %-11s | %-8s | %-28s | %-24s | %-27s |\n" \
                  "" "${MODE}" "${COMPILE_COLUMN}" "${RUN_COLUMN}" "${BYTECODE_COLUMN}" >> time_report.md
              fi
            done
          done

      - name: Update job summary
        run: cat report.md >> "${GITHUB_STEP_SUMMARY}"

      - name: Update job summary with time report
        run: cat time_report.md >> "${GITHUB_STEP_SUMMARY}"

      - name: Upload report
        if: ${{ github.event_name == 'pull_request' }}
        uses: mshick/add-pr-comment@v2
        with:
          message-path: report.md
          message-id: 'compatibility-matrix'

      - name: Upload time report
        if: ${{ github.event_name == 'pull_request' }}
        uses: mshick/add-pr-comment@v2
        with:
          message-path: time_report.md
          message-id: 'time-report-table'


  excel-reports:
    if: ${{ inputs.excel-reports == 'true' }}
    runs-on: matterlabs-ci-runner-high-performance
    container:
      image: ghcr.io/matter-labs/zksync-llvm-runner:latest
    needs: test
    steps:
      - name: Download reports
        uses: actions/download-artifact@v4
        with:
          path: data
          pattern: 'results-*'
          merge-multiple: 'false'

      - name: Clean-up files
        working-directory: data
        run: |
          find . -type f -name 'build_*.json' ! -name 'build_sizes*.json' -delete
          find . -type f -name 'test_*.json' -delete
          find .

      - name: Install benchmark-converter
        run: |
          cargo install benchmark-converter \
            --git https://github.com/matter-labs/era-compiler-tester

      - name: Run benchmark converter
        run: benchmark-converter --input-source tooling --output-path benchmarks-llvm.${{ needs.test.outputs.short-sha }}.xlsx ./data

      - name: Upload Excel reports
        id: excel-reports
        uses: actions/upload-artifact@v4
        with:
          name: excel-reports
          path: benchmarks-llvm.${{ needs.test.outputs.short-sha }}.xlsx

      - name: Add PR comment with excel reports link
        uses: mshick/add-pr-comment@v2
        with:
          message-id: 'excel-reports'
          message: |
            ðŸ“Š **Excel Report Available**

            Benchmarks measured for:
            * solx candidate version: `${{ needs.test.outputs.solx-version }}`
            * solx ToT version: `${{ needs.test.outputs.solx-tot-version }}`
            * solx latest release version: `${{ needs.test.outputs.solx-latest-release-version }}`
            * solc version: `${{ needs.test.outputs.solc-base-version }}`

            âž¡ï¸ [**Download Excel Report**](${{ steps.excel-reports.outputs.artifact-url }})

   # TODO: temporary switch off LNT output, can be returned if required in the future
#  analyze-results:
#    runs-on: matterlabs-ci-runner-high-performance
#    container:
#      image: ghcr.io/matter-labs/zksync-llvm-runner:latest
#    needs: test
#    env:
#      LNT_SERVER_URL: http://llvm-lnt.infra.matterlabs.corp
#      LNT_TEST_SUITE: zksync
#      CONFIG_FILE: lntadmin.yaml
#      DEV_PREFIX: DEV__
#      LNT_RESULTS_FILE: lnt_results.txt
#      CONTEXT_FILE: context.json
#      COMPARISON_FILE: comparison_links.txt
#    steps:
#
#      - name: Checkout LNT
#        uses: actions/checkout@v4
#        with:
#          repository: llvm/llvm-lnt
#          path: lnt
#
#      - name: Setup Python
#        uses: actions/setup-python@v5
#        with:
#          python-version: '3.9'
#
#      - name: Install LNT
#        run: cd lnt && pip install .
#
#      - name: Download reports
#        uses: actions/download-artifact@v4
#        with:
#          path: data
#          merge-multiple: 'true'
#
#      - name: Install LNT benchmark-converter
#        run: |
#          cargo install benchmark-analyzer --bin benchmark-converter \
#            --git https://github.com/matter-labs/era-compiler-tester
#
#      - name: Check data directory
#        run: |
#          ls -la ./data
#          find ./data
#
#      - name: Generate context.json
#        run: |
#          if [[ "${{ github.event_name }}" != "push" ]]; then
#            DEV_MACHINE_PREFIX="${DEV_PREFIX}"
#          fi
#          for COMPILER in solx solx-via-ir solc solc-via-ir; do
#            [[ ${COMPILER} == "solx"* ]] && TOOLCHAIN="ir-llvm" || TOOLCHAIN="evm"
#            [[ ${COMPILER} == "solx"* ]] && VERSION="${{ needs.test.outputs.solx-version }}" || VERSION="${{ needs.test.outputs.solc-base-version }}"
#            [[ ${COMPILER} == *"via-ir" ]] && CODEGEN="via-ir" || CODEGEN="evmla"
#            echo "{
#              \"machine\": \"${DEV_MACHINE_PREFIX}forge-benchmarks-${COMPILER}\",
#              \"target\": \"evm\",
#              \"toolchain\": \"${TOOLCHAIN}\",
#              \"compiler_version\": \"${VERSION}\",
#              \"llvm_version\": \"${{ needs.test.outputs.solx-llvm-version }}\",
#              \"codegen\": \"${CODEGEN}\",
#              \"optimization\": \"Default\"
#            }" > ${CONTEXT_FILE}
#            INPUTS=""
#            rm -f ./data/${COMPILER}/build*.json
#            rm -f ./data/${COMPILER}/test*.json
#            JSONS=$(ls ./data/${COMPILER}/*.json 2>/dev/null)
#            for JSON in ${JSONS}; do
#              if jq empty "${JSON}" > /dev/null 2>&1 && [ -s "${JSON}" ]; then
#                INPUTS+=" --input-paths ${JSON}"
#              fi
#            done
#            benchmark-converter ${INPUTS} \
#              --benchmark-format json-lnt \
#              --benchmark-context ${CONTEXT_FILE} \
#              --output-path ./${COMPILER}
#            mv ./${COMPILER}/* ./lnt-report-${COMPILER}.json
#          done
#
#      - name: Upload results
#        uses: actions/upload-artifact@v4
#        with:
#          name: lnt-reports
#          path: lnt-report*.json
#
#      - name: Submit LNT results
#        shell: bash -ex {0}
#        run: |
#          SUBMIT_URL="${LNT_SERVER_URL}/db_default/v4/${LNT_TEST_SUITE}/submitRun"
#          echo SOLX_LINK=$(lnt submit --ignore-regressions --select-machine=update ${SUBMIT_URL} lnt-report-solx.json) | tee -a ${GITHUB_ENV}
#          echo SOLX_VIA_IR_LINK=$(lnt submit --ignore-regressions --select-machine=update ${SUBMIT_URL} lnt-report-solx-via-ir.json) | tee -a ${GITHUB_ENV}
#          echo SOLC_LINK=$(lnt submit --ignore-regressions --select-machine=update ${SUBMIT_URL} lnt-report-solc.json) | tee -a ${GITHUB_ENV}
#          echo SOLC_VIA_IR_LINK=$(lnt submit --ignore-regressions --select-machine=update ${SUBMIT_URL} lnt-report-solc-via-ir.json) | tee -a ${GITHUB_ENV}
#
#      - name: Publish comparison links
#        if: ${{ github.event_name == 'pull_request' }}
#        shell: bash -ex {0}
#        run: |
#          # Initialize the Markdown table
#          echo '|  Mode   | Link |' > "${COMPARISON_FILE}"
#          echo '|---------|------|' >> "${COMPARISON_FILE}"
#          COMPARISON="[Results](${LNT_SERVER_URL}/db_default/v4/${LNT_TEST_SUITE}/${SOLX_LINK##*/}?compare_to=${SOLC_LINK##*/})"
#          VIA_IR_COMPARISON="[Results](${LNT_SERVER_URL}/db_default/v4/${LNT_TEST_SUITE}/${SOLX_VIA_IR_LINK##*/}?compare_to=${SOLC_VIA_IR_LINK##*/})"
#          echo "| default | ${COMPARISON} |" >> "${COMPARISON_FILE}"
#          echo "| via-ir | ${VIA_IR_COMPARISON} |" >> "${COMPARISON_FILE}"
#          cat "${COMPARISON_FILE}"
#
#      - name: Posting LNT comparison
#        if: ${{ github.event_name == 'pull_request' }}
#        uses: mshick/add-pr-comment@v2
#        with:
#          message-path: ${{ env.COMPARISON_FILE }}
#          message-id: comparison_links
